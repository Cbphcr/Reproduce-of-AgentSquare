{
    "thought": "After analyzing the discovered memory modules, it's evident that the performance can be enhanced by not just storing and retrieving task trajectories based on similarity but also by incorporating a feedback loop that evaluates the effectiveness of retrieved memories in solving the current task. This involves dynamically adjusting the memory retrieval process based on the success rate of past retrievals. The proposed memory module, 'AdaptiveMemory', will store task resolution trajectories along with their success metrics. When retrieving, it will not only consider the similarity of the task but also the past success rate of the retrieved memory in aiding task completion. This adaptive approach ensures that the memory module evolves over time, prioritizing more effective strategies.",
    "name": "adaptive",
    "code": "class MemoryAdaptive(MemoryBase):\n    def __init__(self, llms_type) -> None:\n        super().__init__(llms_type, 'adaptive')\n        self.success_rates = {}  # To track the success rate of each memory\n\n    def retriveMemory(self, query_scenario):\n        # Extract task name from query scenario\n        task_name = re.findall(r'Your task is to:\\s*(.*?)\\s*>', query_scenario)[2]\n        \n        # Return empty string if memory is empty\n        if self.scenario_memory._collection.count() == 0:\n            return ''\n            \n        # Find most similar memories\n        similarity_results = self.scenario_memory.similarity_search_with_score(\n            task_name, k=3)\n            \n        # Filter memories with the highest success rates\n        scored_memories = []\n        for result in similarity_results:\n            memory_id = result[0].metadata['memory_id']\n            success_rate = self.success_rates.get(memory_id, 0.5)  # Default to 0.5 if not found\n            scored_memories.append((result, success_rate))\n        \n        # Sort memories by success rate (descending)\n        scored_memories.sort(key=lambda x: x[1], reverse=True)\n        \n        # Return the trajectory with the highest success rate\n        return scored_memories[0][0][0].metadata['task_trajectory']\n\n    def addMemory(self, current_situation):\n        # Extract task description\n        task_name = re.search(r'Your task is to:\\s*(.*?)\\s*>', current_situation).group(1)\n        memory_id = str(uuid.uuid4())\n        \n        # Create document with metadata\n        memory_doc = Document(\n            page_content=task_name,\n            metadata={\n                \"task_name\": task_name,\n                \"task_trajectory\": current_situation,\n                \"memory_id\": memory_id\n            }\n        )\n        \n        # Add to memory store\n        self.scenario_memory.add_documents([memory_doc])\n        \n        # Initialize success rate for this memory\n        self.success_rates[memory_id] = 0.5\n    \n    def update_success_rate(self, memory_id, success):\n        \"\"\"\n        Update the success rate of a memory based on whether it helped in solving the current task.\n        success: boolean indicating whether the memory was helpful\n        \"\"\"\n        if memory_id in self.success_rates:\n            current_rate = self.success_rates[memory_id]\n            # Simple moving average update\n            new_rate = current_rate * 0.9 + (1 if success else 0) * 0.1\n            self.success_rates[memory_id] = new_rate",
    "performance": 0.8
}