{
    "thought": "The discovered memory modules primarily focus on storing and retrieving task resolution trajectories based on task names or summaries, with varying degrees of success. However, none explicitly leverage the hierarchical structure of tasks and subtasks inherent in ALFworld's sequential decision-making tasks. My next memory module, 'ContextAwareMemory', will not only store the task trajectories and their decompositions but also the context in which each action was taken, including the state of the environment and the agent's internal reasoning at each step. This approach aims to provide more nuanced guidance by understanding the 'context' behind each action, enabling the agent to adapt previous solutions to new tasks more effectively by considering the environmental and internal states that influenced past decisions.",
    "name": "contextaware",
    "code": "class MemoryContextAware(MemoryBase):\n    def __init__(self, llms_type) -> None:\n        super().__init__(llms_type, 'contextaware')\n\n    def retriveMemory(self, query_scenario):\n        # Extract task name from query scenario\n        task_name = re.findall(r'Your task is to:\\s*(.*?)\\s*>', query_scenario)[2]\n        \n        # Return empty string if memory is empty\n        if self.scenario_memory._collection.count() == 0:\n            return ''\n            \n        # Find most similar memory\n        similarity_results = self.scenario_memory.similarity_search_with_score(\n            task_name, k=1)\n            \n        # Extract task contexts and trajectories from results\n        task_contexts = [\n            result[0].metadata['task_context'] for result in similarity_results\n        ]\n        task_trajectories = [\n            result[0].metadata['task_trajectory'] for result in similarity_results\n        ]\n        \n        # Generate a plan based on the context of the task\n        prompt = f'''Given the following task context from a similar task, devise a plan for the current task. Focus on adapting the context and reasoning, not the specific objects or actions.\n\nTask Context:\n{task_contexts[0]}\n\nCurrent Task:\n{query_scenario}\n\nPlan:\n'''\n        plan = llm_response(prompt=prompt, model=self.llm_type, temperature=0.1)\n        \n        return f'Adapted Plan based on Context-Aware Memory:\\n{plan}\\n\\nOriginal Trajectory for Reference:\\n{task_trajectories[0]}'\n\n    def addMemory(self, current_situation):\n        # Extract task description\n        task_name = re.search(r'Your task is to:\\s*(.*?)\\s*>', current_situation).group(1)\n        \n        # Generate a context-aware decomposition of the task\n        prompt = f'''Analyze the following task to extract the context in which each action was taken, including the state of the environment and the agent's internal reasoning at each step. Focus on the context and purpose of each action, not the specific objects or actions.\n\nTask:\n{current_situation}\n\nContext-Aware Decomposition:\n'''\n        context = llm_response(prompt=prompt, model=self.llm_type, temperature=0.1)\n        \n        # Create document with metadata\n        memory_doc = Document(\n            page_content=task_name,\n            metadata={\n                \"task_name\": task_name,\n                \"task_trajectory\": current_situation,\n                \"task_context\": context\n            }\n        )\n        \n        # Add to memory store\n        self.scenario_memory.add_documents([memory_doc])\n    ",
    "performance": 1.0
}