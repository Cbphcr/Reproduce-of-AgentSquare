{
    "thought": "The discovered memory modules primarily focus on storing and retrieving task resolution trajectories based on task names or summaries, with varying degrees of success. However, none explicitly leverage the hierarchical structure of tasks and subtasks inherent in ALFworld's sequential decision-making tasks. My next memory module, 'HierarchicalMemory', will store not just the task trajectories but also the decomposition of tasks into subtasks, their relationships, and the reasoning behind each step. This approach aims to provide more nuanced guidance by understanding the 'why' behind each action, not just the 'what'. By embedding the hierarchical task structure into memory, the agent can retrieve not just similar tasks but also understand how to adapt previous solutions to new but structurally similar tasks.",
    "name": "hierarchical",
    "code": "class MemoryHierarchical(MemoryBase):\n    def __init__(self, llms_type) -> None:\n        super().__init__(llms_type, 'hierarchical')\n\n    def retriveMemory(self, query_scenario):\n        # Extract task name from query scenario\n        task_name = re.findall(r'Your task is to:\\s*(.*?)\\s*>', query_scenario)[2]\n        \n        # Return empty string if memory is empty\n        if self.scenario_memory._collection.count() == 0:\n            return ''\n            \n        # Find most similar memory\n        similarity_results = self.scenario_memory.similarity_search_with_score(\n            task_name, k=1)\n            \n        # Extract task hierarchies and trajectories from results\n        task_hierarchies = [\n            result[0].metadata['task_hierarchy'] for result in similarity_results\n        ]\n        task_trajectories = [\n            result[0].metadata['task_trajectory'] for result in similarity_results\n        ]\n        \n        # Generate a plan based on the hierarchical structure of the task\n        prompt = f'''Given the following task hierarchy from a similar task, devise a plan for the current task. Focus on adapting the structure and reasoning, not the specific objects or actions.\n\nTask Hierarchy:\n{task_hierarchies[0]}\n\nCurrent Task:\n{query_scenario}\n\nPlan:\n'''\n        plan = llm_response(prompt=prompt, model=self.llm_type, temperature=0.1)\n        \n        return f'Adapted Plan based on Hierarchical Memory:\\n{plan}\\n\\nOriginal Trajectory for Reference:\\n{task_trajectories[0]}'\n\n    def addMemory(self, current_situation):\n        # Extract task description\n        task_name = re.search(r'Your task is to:\\s*(.*?)\\s*>', current_situation).group(1)\n        \n        # Generate a hierarchical decomposition of the task\n        prompt = f'''Decompose the following task into subtasks and describe the reasoning behind each step. Focus on the structure and purpose of each action, not the specific objects or actions.\n\nTask:\n{current_situation}\n\nHierarchical Decomposition:\n'''\n        hierarchy = llm_response(prompt=prompt, model=self.llm_type, temperature=0.1)\n        \n        # Create document with metadata\n        memory_doc = Document(\n            page_content=task_name,\n            metadata={\n                \"task_name\": task_name,\n                \"task_trajectory\": current_situation,\n                \"task_hierarchy\": hierarchy\n            }\n        )\n        \n        # Add to memory store\n        self.scenario_memory.add_documents([memory_doc])",
    "performance": 0.5
}